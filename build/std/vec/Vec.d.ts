import { Clone } from '../clone/Clone';
import { Ord } from '../cmp/Ord';
import { Ordering } from '../cmp/Ordering';
import { PartialEq } from '../cmp/PartialEq';
import { PartialOrd } from '../cmp/PartialOrd';
import { Iter } from '../iter/Iterator';
import { Option } from '../option/Option';
import { Result } from '../result/Result';
import { GroupBy } from '../slice/GroupyBy';
import { Split } from '../slice/Split';
import { Windows } from '../slice/Windows';
import { Tuple } from '../types';
export declare class Vec<T extends PartialEq<T> & PartialOrd<T> & Ord<T>> extends Iter<T> implements Clone<Vec<T>>, PartialEq<Vec<T>>, PartialOrd<Vec<T>>, Ord<Vec<T>> {
    private vec;
    private next_pointer;
    constructor(values?: Iterable<T>);
    truncate(len: number): void;
    swap_remove(index: number): T | undefined;
    insert(index: number, element: T): void;
    remove(index: number): T;
    retain(f: (t: T) => boolean): void;
    push(value: T): void;
    pop(): Option<T>;
    append(other: Vec<T>): void;
    drain(range: [number, number]): T[];
    clear(): void;
    is_empty(): boolean;
    split_of(at: number): T[];
    extend_from_within(range: [number, number]): void;
    dedup(): void;
    splice(range: [number, number], replace_with: Iterable<T>): T[];
    drain_filter(filter: (t: T) => boolean): Vec<T>;
    first(): Option<T>;
    split_first(): Option<[T, T[]]>;
    split_last(): Option<[T, T[]]>;
    last(): Option<T>;
    first_chunk<N extends number>(N: N): Option<Tuple<T, typeof N>>;
    split_first_chunk<N extends number>(N: N): Option<[Tuple<T, typeof N>, T[]]>;
    split_last_chunk<N extends number>(N: N): Option<[Tuple<T, typeof N>, T[]]>;
    last_chunk<N extends number>(N: N): Option<Tuple<T, typeof N>>;
    get(index: number): Option<T>;
    swap(a: number, b: number): void;
    reverse(): void;
    iter(): Iterable<T>;
    windows<N extends number>(size: N): Windows<Tuple<T, N>>;
    chunks<N extends number>(chunk_size: N): Tuple<T, N>[];
    rchunks<N extends number>(chunk_size: N): Tuple<T, N>[];
    group_by(pred: (t: T, u: T) => boolean): GroupBy<T, typeof pred>;
    split_at(mid: number): [T[], T[]];
    split(pred: (t: T) => boolean): Split<T, (t: T) => boolean>;
    contains(t: T): boolean;
    starts_with(needle: Vec<T>): boolean;
    ends_with(needle: Vec<T>): boolean;
    binary_search(x: T): Result<number, number>;
    sort_unstable(): void;
    rotate_left(mid: number): void;
    rotate_right(mid: number): void;
    fill(value: T): void;
    fill_with(f: () => T): void;
    is_sorted(): boolean;
    sort(): void;
    repeat(n: number): Vec<T>;
    len(): number;
    next(): ({
        tag: string;
        is_some(): boolean;
        is_none(): boolean;
        expect(msg: string): never;
        unwrap(): never;
        unwrap_or(fallback: never): never;
        unwrap_or_else(fn: () => never): never;
        map<U extends Clone<U>>(fn: (value: never) => U): Option<U>;
        inspect(fn: (value: never) => void): Option<never>;
        map_or<U_1>(fallback: U_1, fn: (value: never) => U_1): U_1;
        map_or_else<U_2>(fallback: () => U_2, fn: (value: never) => U_2): U_2;
        and<U_3 extends Clone<U_3>>(optb: Option<U_3>): Option<U_3>;
        and_then<U_4 extends Clone<U_4>>(fn: (value: never) => Option<U_4>): Option<U_4>;
        filter(predicate: (value: never) => boolean): Option<never>;
        or(optb: Option<never>): Option<never>;
        or_else(fn: () => Option<never>): Option<never>;
        xor(optb: Option<never>): Option<never>;
        zip<U_5 extends Clone<U_5>>(other: Option<U_5>): Option<[never, U_5]>;
        zip_with<U_6 extends Clone<U_6>, R extends Clone<R>>(other: Option<U_6>, fn: (t: never, u: U_6) => R): Option<R>;
    } & Clone<Option<never>> & PartialEq<Option<never>> & PartialOrd<Option<never>> & Ord<Option<never>> & {
        tag: "none";
        is_some(): false;
        is_none(): true;
    }) | ({
        tag: string;
        is_some(): boolean;
        is_none(): boolean;
        expect(msg: string): T;
        unwrap(): T;
        unwrap_or(fallback: T): T;
        unwrap_or_else(fn: () => T): T;
        map<U_7 extends Clone<U_7>>(fn: (value: T) => U_7): Option<U_7>;
        inspect(fn: (value: T) => void): Option<T>;
        map_or<U_8>(fallback: U_8, fn: (value: T) => U_8): U_8;
        map_or_else<U_9>(fallback: () => U_9, fn: (value: T) => U_9): U_9;
        and<U_3 extends Clone<U_3>>(optb: Option<U_3>): Option<U_3>;
        and_then<U_10 extends Clone<U_10>>(fn: (value: T) => Option<U_10>): Option<U_10>;
        filter(predicate: (value: T) => boolean): Option<T>;
        or(optb: Option<T>): Option<T>;
        or_else(fn: () => Option<T>): Option<T>;
        xor(optb: Option<T>): Option<T>;
        zip<U_11 extends Clone<U_11>>(other: Option<U_11>): Option<[T, U_11]>;
        zip_with<U_12 extends Clone<U_12>, R_1 extends Clone<R_1>>(other: Option<U_12>, fn: (t: T, u: U_12) => R_1): Option<R_1>;
    } & Clone<Option<T>> & PartialEq<Option<T>> & PartialOrd<Option<T>> & Ord<Option<T>> & {
        tag: "some";
        is_some(): true;
        is_none(): false;
    });
    clone(): Vec<T>;
    clone_from(source: Vec<T>): void;
    eq(rhs: Vec<T>): boolean;
    ne(rhs: Vec<T>): boolean;
    partial_cmp(rhs: Vec<T>): Option<Ordering>;
    cmp(rhs: Vec<T>): Ordering;
    max(rhs: Vec<T>): Vec<T>;
    min(rhs: Vec<T>): Vec<T>;
}
