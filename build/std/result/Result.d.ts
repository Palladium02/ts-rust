import { Clone } from '../clone/Clone';
import { Ord } from '../cmp/Ord';
import { PartialEq } from '../cmp/PartialEq';
import { PartialOrd } from '../cmp/PartialOrd';
import { Option } from '../option/Option';
export declare type Result<T, E> = {
    tag: string;
    is_ok(): boolean;
    is_ok_and(fn: (ok: T) => boolean): boolean;
    is_err(): boolean;
    is_err_and(fn: (err: E) => boolean): boolean;
    unwrap(): T;
    unwrap_or(fallback: T): T;
    unwrap_or_else(op: (err: E) => T): T;
    unwrap_err(): E;
    ok(): Option<T>;
    err(): Option<E>;
    map<U>(fn: (ok: T) => U): Result<U, E>;
    map_or<U>(fallback: U, fn: (ok: T) => U): U;
    map_or_else<U>(fallback: (err: E) => U, fn: (ok: T) => U): U;
    map_err<U>(fn: (err: E) => U): Result<T, U>;
    inspect(fn: (ok: T) => void): Result<T, E>;
    inspect_err(fn: (err: E) => void): Result<T, E>;
    expect(msg: string): T;
    expect_err(msg: string): E;
    and<U>(res: Result<U, E>): Result<U, E>;
    and_then<U>(op: (ok: T) => Result<U, E>): Result<U, E>;
    or(res: Result<T, E>): Result<T, E>;
    or_else<U>(op: (err: E) => U): Result<T, U>;
} & Clone<Result<T, E>> & PartialEq<Result<T, E>> & PartialOrd<Result<T, E>> & Ord<Result<T, E>>;
export declare function Ok<T>(ok: T): Result<T, never>;
export declare function Err<E>(err: E): Result<never, E>;
