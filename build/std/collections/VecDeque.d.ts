import { Clone } from '../clone/Clone';
import { Ord } from '../cmp/Ord';
import { Ordering } from '../cmp/Ordering';
import { PartialEq } from '../cmp/PartialEq';
import { PartialOrd } from '../cmp/PartialOrd';
import { Iter } from '../iter/Iterator';
import { Option } from '../option/Option';
import { Result } from '../result/Result';
export declare class VecDeque<T extends PartialEq<T> & PartialOrd<T> & Ord<T>> extends Iter<T> implements Clone<VecDeque<T>>, PartialEq<VecDeque<T>>, PartialOrd<VecDeque<T>>, Ord<VecDeque<T>> {
    private vec;
    constructor(values?: Iterable<T>);
    get(index: number): Option<T>;
    swap(a: number, b: number): void;
    truncate(len: number): void;
    len(): number;
    is_empty(): boolean;
    range<R extends [number, number]>(range: R): Iter<T>;
    drain<R extends [number, number]>(range: R): T[];
    clear(): void;
    contains(t: T): boolean;
    front(): Option<T>;
    back(): Option<T>;
    pop_front(): Option<T>;
    pop_back(): Option<T>;
    push_front(value: T): void;
    push_back(value: T): void;
    swap_remove_front(index: number): Option<T>;
    swap_remove_back(index: number): Option<T>;
    insert(index: number, value: T): void;
    remove(index: number): {
        tag: string;
        is_some(): boolean;
        is_none(): boolean;
        expect(msg: string): T;
        unwrap(): T;
        unwrap_or(fallback: T): T;
        unwrap_or_else(fn: () => T): T;
        map<U extends Clone<U>>(fn: (value: T) => U): Option<U>;
        inspect(fn: (value: T) => void): Option<T>;
        map_or<U_1>(fallback: U_1, fn: (value: T) => U_1): U_1;
        map_or_else<U_2>(fallback: () => U_2, fn: (value: T) => U_2): U_2;
        and<U_3 extends Clone<U_3>>(optb: Option<U_3>): Option<U_3>;
        and_then<U_4 extends Clone<U_4>>(fn: (value: T) => Option<U_4>): Option<U_4>;
        filter(predicate: (value: T) => boolean): Option<T>;
        or(optb: Option<T>): Option<T>;
        or_else(fn: () => Option<T>): Option<T>;
        xor(optb: Option<T>): Option<T>;
        zip<U_5 extends Clone<U_5>>(other: Option<U_5>): Option<[T, U_5]>;
        zip_with<U_6 extends Clone<U_6>, R extends Clone<R>>(other: Option<U_6>, fn: (t: T, u: U_6) => R): Option<R>;
    } & Clone<Option<T>> & PartialEq<Option<T>> & PartialOrd<Option<T>> & Ord<Option<T>> & {
        tag: "some";
        is_some(): true;
        is_none(): false;
    };
    split_of(at: number): VecDeque<T>;
    append(other: VecDeque<T>): void;
    retain<F extends (t: T) => boolean>(f: F): void;
    rotate_left(mid: number): void;
    rotate_right(mid: number): void;
    binary_search(x: T): Result<number, number>;
    next(): Option<T>;
    clone(): VecDeque<T>;
    clone_from(source: VecDeque<T>): void;
    eq(rhs: VecDeque<T>): boolean;
    ne(rhs: VecDeque<T>): boolean;
    partial_cmp(rhs: VecDeque<T>): Option<Ordering>;
    cmp(rhs: VecDeque<T>): Ordering;
    max(rhs: VecDeque<T>): VecDeque<T>;
    min(rhs: VecDeque<T>): VecDeque<T>;
}
